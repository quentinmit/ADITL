head	1.4;
access;
symbols;
locks
	reidw:1.4; strict;
comment	@# @;


1.4
date	2005.04.10.18.48.04;	author reidw;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.27.20.21.51;	author reidw;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.20.07.14.02;	author reidw;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.05.04.49.07;	author reidw;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@package Database;

require Exporter;
@@ISA = qw(Exporter);

#@@EXPORT_OK = qw(new, connect);
@@EXPORT_OK = qw();


use strict;

use Pg; #for DB conectivity.

#good random seed. from programming perl.
srand ( time() ^ ($$ + ($$ << 15)) ); 

# creates new DB object.
sub new {
    my $classname = shift;
    my $object = {};
    bless($object, $classname);
    return $object;
}

#takes database name to connect to.
#returns a 1 if success, 0 otherwise.
#assumes password is empty.
sub connect {
    my $self = shift;
    my $dbname = shift;
    my $conn = Pg::setdb("localhost", "", "", "", $dbname);
    $self->{connection} = $conn;
    my $status = ($conn->status == 0)? 1 : 0;
    return $status
}

# adds the given authToken and returns the token index (used to later retrieve the token),
# which should be added as a cookie to the browser in addition to the token itself.
# The token value should be but may not be unique, so the token index is just a way to
# uniqueley name the token.

# takes user's id, token value.
sub addAuthToken {
    my $self = shift;
    my $uid = shift;
    my $tokenValue = shift;

    my $conn = $self->{connection};

    $conn->exec("delete from cookies where uid = '$uid';");
    # remove user's other cookies.

    my $result = $conn->exec("select nextval('cookies_seq');");
    my @@row = $result->fetchrow();
    return 0 unless(@@row);
    my $cid = $row[0];

    #not we're not implementing cookies that expire.
    my $query = "insert into cookies (cookie_id, uid, cookie_value)
values ($cid, $uid, $tokenValue);";

    $conn->exec($query);
    return $cid;
}

# takes token index and list ref. Sets list to (token value, uid) on successs, and
# returns 1. Returns 0 if token doesn't exist.
sub getAuthToken {
    my $self = shift;
    my $tokenId = shift;
    my $listref = shift;

    my $conn = $self->{connection};

    my $query = "select cookie_value, uid from cookies where cookie_id = '$tokenId';";
    my $res = $conn->exec($query);

    my @@row = $res->fetchrow();

    return 0 unless(@@row);

    push(@@$listref, @@row);
    return 1;

}

# returns uid if user exists. 0 otherwise.
sub userExists {
    my $self = shift;
    my $email = shift;
    
    my $conn = $self->{connection};
    my $res = $conn->exec("select uid from users where email = '$email';");
    my @@rows = $res->fetchrow();
    if(scalar(@@rows) == 0) {
	return 0;
    } else {
	return $rows[0];
    }
}

# registers a new user (not yet validated however)
sub registerUser {
    my $self = shift;
    my $fn = shift;
    my $ln = shift;
    my $email = shift;
    my $pw = shift;
    my $affil = shift;
    my $tk = shift; #validation token.

    my $conn = $self->{connection};

    my $res = $conn->exec("select nextval('users_seq');");
    my @@row = $res->fetchrow();
    return 0 unless(@@row);
    my $uid = $row[0];
    my $query = "insert into users (uid, email, first_name, last_name, password, affiliation, validate_token) values ($uid, '$email', '$fn', '$ln', '$pw', '$affil', '$tk');";
    $res = $conn->exec($query);
    return $uid;
}

sub completeRegistration {
    my $self = shift;
    my $uid = shift;
    my $token = shift;

    my $conn = $self->{connection};

    my $query = "select validate_token from users where uid = $uid;";
    my $res = $conn->exec($query);
    my @@row = $res->fetchrow();
    if(scalar(@@row) == 0) {
	return 0;
    }

    my $foundTk = $row[0];
    if($token == $foundTk) {
	$query = "update users set validated = 1 where uid = $uid;";
	$conn->exec($query);
	return 1;
    } else {
	return 0;
    }
}
	


#takes a time in the format 2003-01-03 03:46:00-05 for example
#and returns the hours, minutes, seconds in a list.
sub fixTime {
    shift;
    my $time = shift;
    my @@split1 = split(/ /, $time);
    my @@split2 = split(/\-/, $split1[1]);
    my @@times = split(/:/, $split2[0]);
    return @@times;
}

sub howManyRegistered {
    my $self = shift;

    my $conn = $self->{connection};

    my $query = "select count(*) from users;";
    my $res = $conn->exec($query);
    my @@row = $res->fetchrow();
    if(scalar(@@row) == 0) {
	return 0;
    }

    return $row[0];
}
@


1.3
log
@*** empty log message ***
@
text
@d159 15
@


1.2
log
@*** empty log message ***
@
text
@d109 1
d118 1
a118 1
    my $query = "insert into users (uid, email, first_name, last_name, password, validate_token) values ($uid, '$email', '$fn', '$ln', '$pw', '$tk');";
@


1.1
log
@Initial revision
@
text
@d6 1
a6 3
#@@EXPORT_OK = qw(new, connect, photosByTime, photosByUser, getUserName,
#		getFullName, getAllUsers, getPhotoData, getAllUserData, getRandomGoodPhoto,
#		userTimelineLog, timeTimelineLog);
d84 60
d145 1
@
